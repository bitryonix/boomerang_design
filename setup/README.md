# Boomerang Setup Procedure

For the message sequence diagram, please refer to the [svg](setup_diagram_without_states.svg) file.

1. Phone receives {doxing_password, sar_ids_collection, static_doxing_data} from User and saves doxing_key (SHA256 digest of doxing_password) to encrypt dynamic_doxing_data (e.g. location). It then sends doxing_data_identifier (SHA_256 digest of doxing_key) to SAR to initialize setup.
2. SAR receives doxing_data_identifier from Phone and responds with a newly generated sar_service_fee_payment_info.
3. Phone receives sar_service_fee_payment_info from SAR and forwards it to User.
4. User receives sar_service_fee_payment_info from Phone, verifies and pays the invoice generating sar_service_fee_payment_receipts as a result. He then inputs sar_service_fee_payment_receipts back to phone.
5. Phone receives sar_service_fee_payment_receipts from User and forwards it to SAR alongside encrypted static_doxing_data, encrypted dynamic_doxing_data and doxing_data_identifier.
6. SAR receives {sar_service_fee_payment_receipts, static_doxing_data_encrypted_by_doxing_key, doxing_data_identifier, dynamic_doxing_data_encrypted_by_doxing_key} from Phone, verifies sar_service_fee_payment_receipts, stores encrypted_doxing_data associating it with doxing_data_identifier and responds to Phone informing it they're in sync. Phone will continue generating and sending encrypted_dynamic_doxing_data.
7. Phone receives {magic: "setup_sar_setup_done_and_in_sync_with_phone"} from SAR and informs User that it's now in-sync with SAR. 
8. User receives {magic: "setup_sar_registered_and_connected_to_phone"} from Phone and proceeds to setup Iso.
9. Iso receives {network, entropy_bytes, passphrase, doxing_password, sar_ids_collection} from User, creates mnemonic and master_xpriv_0 from the input. Then derives purpose_root_xpriv_0 from master_xpriv_0 via the path m/cb86' which is m/52102h in decimal, where purpose (cb86') is the first 2 bytes of sha256("boomerang"), hardened. Iso also creates normal_pubkey_0, that is generated directly from purpose_root_xpub_0. 
10. Boomlet receives {normal_pubkey_0, doxing_key, sar_ids_collection, network} from Iso during installation. Then independently generates boomlet_0_identity_privkey which it uses to encrypt, decrypt and sign messages. It also creates boomlet_0_boom_musig2_privkey_share and boomlet_0_boom_musig2_pubkey_share, that will together with normal_pubkey_0, generate the MuSig2 aggregated public key, named boom_pubkey_0, that is used in boomerang_descriptor. It then responds with boomlet_0_identity_pubkey.
11. Iso receives boomlet_0_identity_pubkey from Boomlet and forwards it to ST.
12. ST receives boomlet_0_identity_pubkey from Boomlet and responds with st_0_identity_pubkey.
13. Iso receives st_0_identity_pubkey from SAR and forwards it to Boomlet.
14. Boomlet receives st_0_identity_pubkey from Iso. It then generates an array of 5 random integers between 1 and 198 named duress_check_space and encrypts it for st. This will be used to record the duress_consent_set input from user.
15. Iso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
16. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Iso. Decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assign a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them as duress_consent_set.
17. User receives duress_check_space from ST. He then selects 5 countries via the ST's joystick. ST will record the index in the duress_signal_index User is to memorize the name of 5 countries that they have selected in this stage.
18. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for Boomlet and sends it to Iso.
19. Iso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
20. Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Iso and decrypts it to get duress_signal_index_with_nonce. After checking the nonce to be the same as the one sent  It will search for the newly received indices in duress_check_space store those numbers corresponding to aforementioned indices as duress_consent_set, and drops redundant data. It then generates another duress_check_space, and repeat the same process and sends a fresh duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st to Iso.
21. Iso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
22. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Iso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assign a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them as confirmation of duress_consent_set.
23. User receives duress_check_space from ST. He will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.
24. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for Boomlet and sends it to Iso.
25. Iso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
26. Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Iso. Boomlet will search for the indices in duress_check_space. If the resulting 5 numbers constitute the same set as the duress_consent_set, Boomlet knows that the user has "memorized" the consent set. If not, there would be a retry from **SetupBoomletIsoMessage3**. If that also fails, the duress setup process will start from **SetupBoomletIsoMessage2** onwards (after key exchange).If all is good, Boomlet will drop the redundant data.
27. Iso receives {magic: "setup_duress_finished"} from Boomlet and knowing Boomlet can be disconnected returns mnemonic to User.
28. User receives mnemonic from Iso, saves it in a safe place and proceeds to shutdown Iso and connect Boomlet to Niso to continue setup.
29. Niso receives {network, rpc_client_url, rpc_client_auth} from User during the installation. rpc_client_url and rpc_client_auth provides a direct view into the provided network. As Niso communicates through TOR, Niso asks for peer_0_tor_secret_key from Boomlet.
30. Boomlet receives {magic: "setup_initialized"} from Niso. It then derives peer_0_tor_address from peer_0_tor_secret_key, signs it and responds with peer_0_id, peer_0_tor_secret_key and peer_0_tor_address_signed_by_boomlet_0.
31. Niso receives {peer_0_id, peer_0_tor_secret_key, peer_0_tor_address_signed_by_boomlet_0} from Boomlet. It verifies the signature on peer_0_tor_address_signed_by_boomlet_0 using boomlet_0_identity_pubkey that it got in peer_0_id. Niso then runs a tor circuit using peer_0_tor_secret_key and generates peer_0_tor_address in doing so. It checks the generated peer_0_tor_address to be equal with the signed one and forwards peer_0_id and peer_0_tor_address_signed_by_boomlet_0 to ST.
32. ST receives {peer_0_id, peer_0_tor_address_signed_by_boomlet_0} from Niso. Since ST already knows boomlet_0_identity_pubkey it checks the peer_0_id to make sure it contains the same identity pubkey for Boomlet.
33. User receives {peer_0_id, peer_0_tor_address_signed_by_boomlet_0} from ST and proceeds to share it with peers in an out-of-band channel. 
34. User receives {peer_i_id, peer_i_tor_address_signed_by_boomlet_i} from peers, sending his own {peer_0_id, peer_0_tor_address_signed_by_boomlet_0} at the same time. It then forms peer_addresses_collection from pairs <peer_i_id, peer_i_tor_address_signed_by_boomlet_i> and inputs it alongside wt_ids_collection and milestone_block_collection into Niso. 
35. Niso receives {peer_addresses_collection, wt_ids_collection, milestone_block_collection} from User. It checks the peer_i_id.boomlet_i_identity_pubkey's signature on every peer_i_tor_address_signed_by_boomlet_i and if successful attempts connecting to all of them. He then checks inclusion of <peer_0_id, peer_0_tor_address_signed_by_boomlet_0> in peer_addresses_collection and forwards the received values to Boomlet.
36. Boomlet receives {peer_addresses_collection, wt_ids_collection, milestone_block_collection} from Niso. It checks the peer_i_id.boomlet_i_identity_pubkey's signature on every peer_i_tor_address_signed_by_boomlet_i, checks inclusion of <peer_0_id, peer_0_tor_address_signed_by_boomlet_0> in peer_addresses_collection. TO verify boomerang_params_seed that includes peer_ids, wt_ids and milestone_block_collection with User it adds nonce to it to get boomerang_params_with_nonce, encrypts boomerang_params_with_nonce for ST and sends boomerang_params_seed_encrypted_by_boomlet_0_for_st to Niso.
37. Niso receives boomerang_params_seed_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
38. ST receives boomerang_params_seed_encrypted_by_boomlet_0_for_st from Niso and decrypts it to get boomerang_params_seed_with_nonce separates boomerang_params_seed_with_nonce.content to get boomerang_params_seed which it sends to User.
39. User receives boomerang_params_seed from ST and checks the correctness of it's peer_ids, wt_ids and milestone_block_collection. He then informs ST of his agreement with the given values.
40. ST receives {magic: "setup_user_verified_peer_ids_and_wt_ids_received_with_those_registered_before"} from User and proceeds to sign the received boomerang_params_seed_with_nonce, encrypt it for boomlet and send it to Niso.
41. Niso receives boomerang_params_seed_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
42. Boomlet receives boomerang_params_seed_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from Niso. Boomerang decrypts boomerang_params_seed_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 to get boomerang_params_seed_with_nonce_signed_by_st, checks the signature on boomerang_params_seed_with_nonce_signed_by_st using st_0_identity_pubkey, and checks the content of it to match boomerang_params_seed_with_nonce sent before concluding that User verified the boomerang_params_seed. It then constructs boomerang_descriptor using network, milestone_block_collection and peer_ids. milestone_block_0 marks the block that N of N of the boom_keys can spend. milestone_block_1 marks the block that enables deterministic spending i.e. N of N of the normal_keys can spend. other milestone_blocks decrease the number of peers required to sign with their normal_pubkey. It then forms boomerang_params made up of peer_ids, wt_ids and boomerang_descriptor. Then signs and sends it to Niso. 
43. Niso receives boomerang_params_signed_by_boomlet_0 from Boomlet and proceeds to share it with other peers' Nisos.
44. Niso receives boomerang_params_signed_by_boomlet_i from peers, sending boomerang_params_signed_by_boomlet_0 at the same time. It checks the content of each to be equal to boomerang_params_signed_by_boomlet_0 and for the signatures to be valid.  It then forms boomerang_params_signed_by_all_peers: Collection<(boomerang_params_signed_by_boomlet_i)> and sends it to Boomlet.
45. Boomlet receives boomerang_params_signed_by_all_peers from Niso. It checks the content of each peer's boomerang_params_signed_by_boomlet_i to be equal to boomerang_params_signed_by_boomlet_0 and for the signatures to match peer_i.boomlet_i_identity_pubkey.  If the message checks out, Boomlet fixes the boomerang_params as an agreed upon value between peers, changing of which will be addressed in ancillary. It then informs Niso that boomerang_params is fixed.
46. Niso receives {magic: "setup_boomerang_params_fixed"} from Boomlet and informs it to generate the mystery value that's used for withdrawal.
47. Boomlet receives {magic: "setup_boomerang_params_fixed"} from Niso. Boomlet then generates mystery as a random integer between MIN_TRIES_FOR_DIGGING_GAME_IN_BLOCKS and MAX_TRIES_FOR_DIGGING_GAME_IN_BLOCKS, Initializes the counter value as 0, hashes boomerang_params using sha256 to get boomerang_params_fingerprint and signs it to get boomerang_params_fingerprint_signed_by_boomlet_0, sorts peer_ids.boomlet_i_identity_pubkey values and signs it to get sorted_all_peers_boomlet_identity_pubkeys_signed_by_boomlet_0 and sends this alongside sorted_all_peers_boomlet_identity_pubkeys_signed_by_boomlet_0 to Niso.
48. Niso receives {sorted_all_peers_boomlet_identity_pubkeys_signed_by_boomlet_0, boomerang_params_fingerprint_signed_by_boomlet_0} from Boomlet and forwards them alongside boomlet_0_identity_pubkey and peer_0_tor_address_signed_by_boomlet_0 to WT.
49. WT receives {boomlet_i_identity_pubkey, sorted_all_peers_boomlet_identity_pubkeys_signed_by_boomlet_i, peer_i_tor_address_signed_by_boomlet_i, boomerang_params_fingerprint_signed_by_boomlet_i} from Niso and Peers. WT checks the signature of the received boomlet_i_identity_pubkey on the corresponding sorted_all_peers_boomlet_identity_pubkeys_signed_by_boomlet_i, peer_i_tor_address_signed_by_boomlet_i and boomerang_params_fingerprint_signed_by_boomlet_i. It then responds to each peer's Niso with an invoice made for that peer.
50. Niso receives wt_service_fee_payment_info from WT and outputs it to User.
51. User receives wts_service_fee_payment_info from Niso, verifies the service_fee_invoice and wt_id and pays the invoice generating wt_service_fee_payment_receipt as a result.
52. Niso receives wt_service_fee_payment_receipt from User and forwards it to WT.
53. WT receives wt_service_fee_payment_receipt from Niso and verifies it. It then signs the previously received boomerang_params_fingerprint and returns boomerang_params_fingerprint_signed_by_wt to Niso. 
54. Niso receives boomerang_params_fingerprint_signed_by_wt from WT. Niso verifies wt_pubkey's signature, checks that the content matches the boomerang_params_fingerprint_signed_by_boomlet_0 that was previously sent and forwards it to Boomlet.
55. Boomlet receives boomerang_params_fingerprint_signed_by_wt from WT, checks the content to match what was previously sent and verifies the signature using wt_pubkey. It then hashes boomerang_params alongside {magic: "setup_wt_service_initialized"} to get shared_state_active_wt_fingerprint and signs it to get shared_state_active_wt_fingerprint_signed_by_boomlet_0, returning this to Niso to check if other peers have also finalized the same wt.
56. Niso receives shared_state_active_wt_fingerprint_signed_by_boomlet_0 and proceeds to share it with Peers.
57. Niso receives shared_state_active_wt_fingerprint_signed_by_boomlet_i from peers, sending shared_state_active_wt_fingerprint_signed_by_boomlet_0 at the same time. It verifies boomlet_i_identity_pubkey's signature on each and the contents to match the one signed by boomlet_0, then forms shared_state_active_wt_fingerprint_signed_by_all_peers: Collection<shared_state_active_wt_fingerprint_signed_by_boomlet_i> and sends it to Boomlet.
58. Boomlet receives shared_state_active_wt_fingerprint_signed_by_all_peers from Niso. It checks the content of each peer's shared_state_active_wt_fingerprint_signed_by_boomlet_i to be equal to shared_state_active_wt_fingerprint_signed_by_boomlet_0 and for the signatures to match peer_i.boomlet_i_identity_pubkey. It then informs Niso that wt is confirmed and active for all peers.
59. Niso receives {magic: "setup_wt_service_confirmed_by_peers"} from Boomlet and informs Boomlet to finalize sars.
60. Boomlet receives {magic: "setup_wt_service_confirmed_by_peers_sars_can_be_finalized"} from Niso. Boomlet then generates doxing_data_identifier by hashing doxing_key and encrypts it by sar_pubkey. It also signs sar_ids_collection and encrypts sar_ids_collection_signed_by_boomlet_0 it by wt_pubkey. It then sends {sar_ids_collection_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, doxing_data_identifier_encrypted_by_boomlet_0_for_sar} to Niso.
61. Niso receives {sar_ids_collection_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, doxing_data_identifier_encrypted_by_boomlet_0_for_sar} from Boomlet and forwards it to WT. 
62. WT receives {sar_ids_collection_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, doxing_data_identifier_encrypted_by_boomlet_0_for_sar} from Niso and decrypts sar_ids_collection_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt. It then verifies the signature on sar_ids_collection_signed_by_boomlet_0 and if correct sends doxing_data_identifier_encrypted_by_boomlet_0_for_sar alongside boomlet_0_identity_pubkey to the SAR in sar_ids_collection.
63. SAR receives {doxing_data_identifier_encrypted_by_boomlet_0_for_sar, boomlet_0_identity_pubkey} from WT. ST decrypts doxing_data_identifier_encrypted_by_boomlet_0_for_sar using boomlet_0_identity_pubkey and checks if the plaintext was previously received as doxing_data_identifier. If True It generates sar_setup_response containing {doxing_data_identifier, fingerprint_of_static_doxing_data_encrypted_by_doxing_key, iv_of_static_doxing_data_encrypted_by_doxing_key} in which fingerprint_of_static_doxing_data_encrypted_by_doxing_key is the sha256 hash of static_doxing_data_encrypted_by_doxing_key and iv_of_static_doxing_data_encrypted_by_doxing_key is the iv used in AES encryption algorithm it got alongside the ciphertext of doxing_data_encrypted_by_doxing_key. SAR then signs sar_setup_response encrypts it with boomlet_0_identity_pubkey and sends the result to WT.
64. WT receives sar_setup_response_signed_by_sar_encrypted_by_sar_for_boomlet_0 from SAR. It then adds the suffix "setup_sar_acknowledgement_of_finalization_received" to it, signs it with wt_privkey and send it to Niso.
65. Niso receives sar_setup_response_signed_by_sar_encrypted_by_sar_for_boomlet_0_suffixed_by_wt_signed_by_wt, checks the signature using wt_pubkey and checks the suffix to match "setup_sar_acknowledgement_of_finalization_received". It then forwards the message to Boomlet.
66. Boomlet receives sar_setup_response_signed_by_sar_encrypted_by_sar_for_boomlet_0_suffixed_by_wt_signed_by_wt from Niso. Boomlet verifies the signature using wt_pubkey and checks the suffix to match "setup_sar_acknowledgement_of_finalization_received". It then decrypts the suffixed content to get sar_setup_response_signed_by_sar, verifies sar_pubkey's signature and makes sure the doxing_data_identifier in sar_setup_response_signed_by_sar matches what was sent to SAR. Boomlet saves sar_setup_response to send to Iso later on and hashes SharedStateSarFinalization{ magic: "setup_wt_received_sar_data"} to get shared_state_active_sar_fingerprint. Then signs it using boomlet_0_identity_pubkey and sends it to Niso.
67. Niso receives shared_state_active_sar_fingerprint_signed_by_boomlet_0 and proceeds to share it with Peers.
68. Niso receives shared_state_active_sar_fingerprint_signed_by_boomlet_i from peers, sending shared_state_active_sar_fingerprint_signed_by_boomlet_0 at the same time. It verifies boomlet_i_identity_pubkey's signature on each and the contents to match the one signed by boomlet_0, then forms shared_state_active_sar_fingerprint_signed_by_all_peers: Collection<shared_state_active_sar_fingerprint_signed_by_boomlet_i> and sends it to Boomlet.
69. Boomlet receives shared_state_active_sar_fingerprint_signed_by_all_peers from Niso. It checks the content of each peer's shared_state_active_sar_fingerprint_signed_by_boomlet_i to be equal to shared_state_active_sar_fingerprint_signed_by_boomlet_0 and for the signatures to match peer_i.boomlet_i_identity_pubkey. It then informs Niso that sar activation is confirmed and active for all peers.
70. Niso receives {magic: "setup_sar_acknowledgement_of_finalization_received"} from Boomlet and informs User to initialize backup.
71. User receives {magic: "setup_sar_finalization_confirmed"} from Niso and proceeds to connect the hardware for Boomletwo, which is going to be the backup of Boomlet, to Iso.
72. Iso is turned on in backup mode indicated by {magic: "setup_user_is_informed_that_sar_is_set_and_can_install_boomlet_backup"} from User and proceeds to install Boomletwo_binary on the hardware.
73. Boomletwo gets installed indicated by {magic: "setup_backup_started"} from Iso. It generates boomletwo_Identity_privkey, derives boomletwo_Identity_pubkey from it and responds to Iso with boomletwo_Identity_pubkey.
74. Iso receives boomletwo_Identity_pubkey from Boomletwo and proceeds to inform User to connect Boomlet.
75. User receives {magic: "setup_boomletwo_identity_pubkey_received_connect_boomlet_to_iso"} from Iso and proceeds to connect Boomlet to Iso and Input the values necessary for backup and for verification of the received doxing_data_fingerprint.
76. Iso receives {milestone_block_collection network mnemonic passphrase static_doxing_data doxing_password} from User. It then generates  backup_request which is composed of {"boomlet_backup_request", boomletwo_Identity_pubkey, normal_pubkey_0}, signs it using normal_privkey_0 and sends the signed value to Boomlet.
77. Boomlet receives backup_request_signed_by_normal_0 from Iso, checks normal_pubkey_0's signature, checks backup_request.magic to match "boomlet_backup_request" and backup_request.backup_normal_key to match normal_pubkey_0. Boomlet then encrypts it's own data except mystery with boomletwo_Identity_pubkey and sends this boomlet_0_backup_encrypted_by_boomlet_0_for_boomletwo, along with boomlet_0_identity_pubkey, boomerang_params and sar_setup_response to Iso.
78. Iso receives {boomlet_0_identity_pubkey, boomlet_0_backup_encrypted_by_boomlet_0_for_boomletwo, boomerang_params, sar_setup_response} from Boomlet. Iso reconstructs the descriptor using {network, boomerang_params.peer_ids, milestone_block_collection} and checks to see if it's same as the one in boomerang_params received.  It then regenerates doxing_key using the inputted doxing_password and doxing_data_identifier using doxing_key. Iso then doxing_data_identifier in sar_setup_response matches the one generated. Then Iso encrypts the static_doxing_data using the iv in sar_setup_response and doxing_key then checks to see if it matches fingerprint_of_static_doxing_data_encrypted_by_doxing_key in sar_setup_response.
79. User receives {magic: "setup_boomlet_backup_data_received_connect_boomletwo_to_iso"} from Iso. User then proceeds to connect Boomletwo to Iso. 
80. Iso receives {magic: "setup_user_is_asked_to_connect_boomletwo_to_iso_boomletwo_connected_to_iso"} from User and proceeds to give the backup file to Boomletwo. 
81. Boomletwo receives {boomlet_0_identity_pubkey, boomlet_0_backup_encrypted_by_boomlet_0_for_boomletwo} from Iso. It decrypts boomlet_0_backup_encrypted_by_boomlet_0_for_boomletwo using boomletwo_identity_privkey diffie-hellman with boomlet_0_identity_pubkey and imports the data into it's memory. It generates it's own mystery and generates backup_done composed of {"boomlet_backup_done", boomletwo_Identity_pubkey, boomlet_0_identity_pubkey} and signs it using boomletwo_Identity_privkey and sends backup_done_signed_by_boomletwo to Iso.
82. Iso receives {backup_done_signed_by_boomletwo} from Boomletwo. Iso proceeds to inform User to connect Boomlet.
83. User receives {magic: "setup_boomlet_backup_done_connect_boomlet_to_iso"} from Iso and connects Boomlet to Iso.
84. Iso receives {magic: "setup_user_is_asked_to_connect_boomlet_to_iso_boomlet_connected_to_iso"} from User and proceeds to forward backup_done_signed_by_boomletwo to Boomlet.
85. Boomlet receives {backup_done_signed_by_boomletwo} from Iso. It verifies boomletwo_identity_pubkey's pubkey on backup_done_signed_by_boomletwo. Boomlet then checks magic,backup_boomlet_pubkey and boomlet_pubkey of backup_done to match expected values.
86. Iso receives {magic: "setup_boomlet_backup_done"} from Boomlet and proceeds to inform User that the backup process has been completed.
87. User receives {magic: "setup_boomlet_backup_completed_boomlet_closed_ready_to_finish_setup"} from Iso. User proceeds to connect Boomlet to Iso.
88. Niso receives {magic: "setup_user_is_informed_that_boomlet_is_closed"} from User and proceeds to tell Boomlet to finish the setup procedure.
89. Boomlet receives {magic: "setup_boomlet_closed_finish_setup"} from Niso and proceeds to generate and hash shared_state_active_backup composed of {magic: "boomlet_backup_done_and_setup_finish_initialized"}. It then signs the digest shared_state_active_backup_fingerprint to get shared_state_active_backup_fingerprint_signed_by_boomlet_0 and sends this value to Niso. 
90. Niso receives shared_state_active_backup_fingerprint_signed_by_boomlet_0 and proceeds to share it with Peers.
91.  Niso receives shared_state_active_backup_fingerprint_signed_by_boomlet_i from peers, sending shared_state_active_backup_fingerprint_signed_by_boomlet_i at the same time.  It  It verifies boomlet_i_identity_pubkey's signature on each and the contents to match the one signed by boomlet_0, then forms shared_state_active_backup_fingerprint_signed_by_all_peers: Collection<shared_state_active_backup_fingerprint_signed_by_boomlet_i> and sends it to Boomlet.
92. Boomlet receives shared_state_active_backup_fingerprint_signed_by_all_peers from Niso. It checks the content of each peer's shared_state_active_backup_fingerprint_signed_by_boomlet_i to be equal to shared_state_active_backup_fingerprint_signed_by_boomlet_0 and for the signatures to match peer_i.boomlet_i_identity_pubkey. It then informs Niso that the setup procedure is finished.
93. Niso receives {magic: "setup_done"} from Boomlet and proceeds to inform User that setup is finished.
94. User receives {magic: "setup_done"} from Niso.
