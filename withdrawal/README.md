# Boomerang withdrawal procedure

1. Niso receives psbt from User. Niso checks that most_work_bitcoin_block_height has passed milestone_block_0 from boomerang_descriptor, derives tx_id from psbt and stores it. Niso also checks to see if psbt inputs are satisfiable. It sends the psbt alongside the latest block height to Boomlet.
2. Boomlet receives {psbt, niso_0_event_block_height} from Niso and checks to see if the niso_0_event_block_height has passed milestone_block_0. Boomlet then derives tx_id from psbt, adds a nonce to it, encrypts it for st_0_identity_pubkey and sends it to Niso.
3. Niso receives tx_id_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
4. ST receives tx_id_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it, separates the nonce and sends the tx_id to User.
5. User receives tx_id from User and checks to see if it matches that of the psbt he generated. He then informs ST of his acknowledgement. 
6. ST receives {magic: "withdrawal_initiator_peer_approved_that_txid_received_is_the_same_as_the_one_derived_from_withdrawal_psbt"} from User. ST then signs the tx_id_with_nonce it received with st_privkey and encrypts it with boomlet_0_identity_pubkey. It then sends this encrypted message to Niso.
7. Niso receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
8. Boomlet receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from Niso, decrypts it, verifies st_0_identity_pubkey's signature and checks if the content is the same as the one sent i.e. User has acknowledged the tx_id and the message is fresh. It then generates peer_0_tx_approval composed of {"approved", tx_id, event_block_height}, signs it with boomlet_0_identity_privkey and encrypts it for wt. It then encrypts psbt for every other boomlet_i using their respective identity_pubkey. Boomlet sends the resulting psbt_encrypted_collection alongside peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
9. Niso receives {peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, psbt_encrypted_collection: Collection<psbt_encrypted_by_boomlet_0_for_boomlet_i> [1 <= i <= 4]} from Boomlet and forwards them to WT.
10. WT receives {peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, psbt_encrypted_collection: Collection<psbt_encrypted_by_boomlet_0_for_boomlet_i> [1 <= i <= 4]} from Niso. WT decrypts peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, verifies boomlet_0_identity_pubkey's signature and checks the string to match "approved". WT stores the tx_id from peer_0_tx_approval and checks that the event_block_height is fresh. Then it constructs it's own tx_approval composed of {"approved",tx_id,most_work_bitcoin_block_height, boomlet_0_identity_pubkey} and signs it. It sends to each non-initiator peer wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0 and psbt encrypted by that peer's boomlet_identity_pubkey.
11. Non-initiator Niso receives {wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0,  psbt_encrypted_by_boomlet_0_for_boomlet_1} from WT. Non-initiator Niso verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt, finds out which peer is the  initiator by looking at the initiator_id field of wt_tx_approval (We consider peer_0 as the initiator). It verifies that the  boomlet_0_identity_pubkey derived from wt_tx_approval exists in the set of peer_ids_collection, It then verifies  boomlet_0_identity_pubkey's signature on peer_0_tx_approval_signed_by_boomlet_0. Non-initiator Niso checks that the magic in  peer_0_tx_approval and wt_tx_approval match "approved" , the tx_id in both approvals is the  same, peer_0_tx_approval is fresh according to wt_tx_approval  and wt_tx_approval is fresh according to most_work_bitcoin_block_height.  It then checks that most_work_bitcoin_block_height has passed milestone_block_0 from boomerang_descriptor and forwards  the received message alongside niso_1_event_block_height to Non-initiator Boomlet.
12. Non-initiator Boomlet receives {wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0, psbt_encrypted_by_boomlet_0_for_boomlet_1, niso_1_event_block_height} from Non-initiator Niso. Non-initiator Boomlet verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt, finds out which peer is the initiator by looking at the initiator_id field of wt_tx_approval. It verifies that the boomlet_0_identity_pubkey derived from wt_tx_approval exists in the set of peer_ids_collection. It then verifies boomlet_0_identity_pubkey's signature on peer_0_tx_approval_signed_by_boomlet_0 and decrypts psbt_encrypted_by_boomlet_0_for_boomlet_1 using boomlet_1_identity_privkey and boomlet_0_identity. Non-initiator Boomlet checks that the magic in peer_0_tx_approval and wt_tx_approval match "approved", the tx_id in both approvals is the same as the one derived from psbt, peer_0_tx_approval is fresh according to wt_tx_approval, wt_tx_approval is fresh according to niso_1_event_block_height and niso_1_event_block_height has passed (is larger than) milestone_block_0. Non-initiator Boomlet then sends psbt to non-initiator Niso.
13. Non-initiator Niso receives psbt from Non-initiator non-initiator Boomlet. Non-initiator Niso checks that psbt is satisfiable and derived tx_id matches that of peer_0_tx_approval. It then outputs psbt along with initiator's peer_i_id to non-initiator User.
14. Non-initiator User receives {psbt, initiator_peer_id} from non-initiator Niso. Non-initiator User then informs non-initiator Niso of it's agreement with the tx.
15. Non-initiator Niso receives {magic: "withdrawal_non_initiator_peer_approved_the_withdrawal_psbt"} from non-initiator User. Non-initiator Niso then informs non-initiator Boomlet to proceed.
16. Non-initiator Boomlet receives {magic: "withdrawal_peer_agreement_with_psbt_received"} from non-initiator Niso. Non-initiator Boomlet then derives tx_id from psbt, adds nonce to it and encrypts it with st_1_identity_pubkey. It then sends tx_id_with_nonce_encrypted_by_boomlet_1_for_st to non-initiator Niso.
17. Non-initiator Niso receives tx_id_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Boomlet and forwards it to non-initiator ST.
18. Non-initiator ST receives tx_id_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Niso. Non-initiator ST decrypts tx_id_with_nonce_encrypted_by_boomlet_1_for_st to get tx_id_with_nonce and outputs the content of it i.e. tx_id to non-initiator User.
19. Non-initiator User receives tx_id from non-initiator ST. Non-initiator User checks to see tx_id matches the one he previously received from non-initiator Niso and agreed to. It then informs non-initiator ST of his agreement.
20. Non-initiator ST receives {magic: "withdrawal_non_initiator_peer_approved_that_txid_received_is_the_same_as_the_one_derived_from_wIthdrawal_psbt"} from non-initiator User. It signs the tx_id_with_nonce, encrypts it with boomlet_1_identity_pubkey and sends the result to non-initiator Niso.
21. Non-initiator Niso receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 from non-initiator ST. Non-initiator Niso forwards tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 along with the updated niso_1_event_block_height to non-initiator Boomlet.
22. Non-initiator Boomlet receives {tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1, niso_1_event_block_height} from non-initiator Niso. Non-initiator Boomlet decrypts tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 using boomlet_1_identity_privkey to get tx_id_with_nonce_signed_by_st. It then verifies st_1_identity_pubkey's signature on tx_id_with_nonce_signed_by_st and checks if the tx_id_with_nonce received matches with the one sent. Non-initiator Boomlet generates peer_1_tx_approval composed of {"approved", tx_id, niso_1_event_block_height}, signs it using boomlet_1_identity_privkey, encrypts it with wt_pubkey and sends peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt to non-initiator Niso.
23. Non-initiator Niso receives peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Boomlet and forwards it to WT.
24. WT receives peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Niso, decrypts it using wt_privkey, verifies boomlet_1_identity_pubkey's signature on peer_1_tx_approval_signed_by_boomlet_1, checks that the magic matches "approved", tx_id match the expected value and message to be fresh according to the most_work_bitcoin_block_height and event_block_height of wt_tx_approval. It also receives peer_i_tx_approval_signed_by_boomlet_i_encrypted_by_boomlet_i_for_wt from non-initiator Peers and repeats the same validation process. WT then sends to each non-initiator peer a collection of all other peers' approvals except the initiator's and in a separate message sends a collection of all peers' approvals along with wt_tx_approval to the initiator peer.
25. Niso receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [0 <= i <= 4], wt_tx_approval_signed_by_wt} from WT. Niso verifies each boomlet_i_identity_pubkey's signature on each peer_i_tx_approval_signed_by_boomlet_i and verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt. It checks the magic string for every approval to match "approved", the tx_id to match what was sent and the event_block_heights to be in the appropriate range. It forwards Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4] along with the latest block to Boomlet.
26. Non-initiator Niso receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4]} from WT. Non-initiator Niso updates niso_1_event_block_height with the latest most_work_bitcoin_block_height. For every non_initiator peer in peer_ids_collection, It verifies boomlet_i_identity_pubkey's signature on peer_i_tx_approval_signed_by_boomlet_i, checks that the magic matches "approved", tx_id to be the expected value, peer_i_tx_approval to be fresh according to niso_1_event_block_height and wt_tx_approval and checks that wt_tx_approval is still fresh. It forwards this Collection<peer_i_tx_approval_signed_by_boomlet_i> alongside niso_1_event_block_height to non-initiator Boomlet.
27. Boomlet receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4], wt_tx_approval_signed_by_wt, niso_0_event_block_height} from WT. Boomlet verifies each boomlet_i_identity_pubkey's signature on each peer_i_tx_approval_signed_by_boomlet_i, verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt and updates niso_0_event_block_height with the new value. It checks the magic string for every approval to match "approved", the tx_id to match what was sent and the event_block_heights to be in the appropriate range. It then generates duress_check_space which is an array of 5 integers between 1 and 198, adds a nonce to it and encrypts it using. Then Boomlet sends duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st to Niso.
27n. Non-initiator Boomlet receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4], niso_1_event_block_height} from non-initiator Niso. After renewing niso_1_event_block_height, for every peer in peer_ids_collection except the initiator, non-initiator Boomlet verifies boomlet_i_identity_pubkey's signature on peer_i_tx_approval_signed_by_boomlet_i, checks that the magic matches "approved", tx_id to be the expected value, peer_i_tx_approval to be fresh according to niso_1_event_block_height and wt_tx_approval and checks that wt_tx_approval is still fresh. It then generates duress_check_space which is an array of 5 integers between 1 and 198, adds a nonce to it and encrypts it using. Then non-initiator Boomlet sends duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st to non-initiator Niso.
28. Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
28n. Non-initiator Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st from  non-initiator Boomlet and forwards it to non-initiator ST.
29. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assign a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them.
29n. Non-initiator ST receives duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st, assign a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to non-initiator User for him to select 5 of them.
30. User receives duress_check_space from ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.
30n. Non-initiator User receives duress_check_space from non-initiator ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.
31. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for Boomlet and sends it to Niso.
31n. Non-initiator ST receives duress_signal_index from non-initiator User. Non-initiator ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for non-initiator Boomlet and sends it to Niso.
32. Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
32n. Non-initiator Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_1 from non-initiator ST and forwards it to non-initiator Boomlet.
33. BBoomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Niso. Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal.  If the duress_signal is composed of the same set of numbers as the duress_consent_set, duress_placeholder_plaintext will be assigned an empty padding otherwise it will be the doxing_key. duress_placeholder_plaintext will be encrypted to make up duress_placeholder. Boomlet then constructs peer_0_tx_commit composed of {"commit" ,tx_id , niso_0_event_block_height}, and signs it, pads it with duress_placeholder, resigns it,d encrypts it with wt_pubkey and sends the result to Niso.
33n. Non-initiator Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_1 from non-initiator Niso. Non-initiator Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal.  If the duress_signal is composed of the same set of numbers as the duress_consent_set, duress_placeholder_plaintext will be assigned an empty padding otherwise it will be the doxing_key. duress_placeholder_plaintext will be encrypted to make up duress_placeholder.  Non-initiator Boomlet then generates approvals composed of peer_i_tx_approval_signed_by_peer_i [0 <= i <= 4] and wt_tx_approval, signs it with boomlet_1_identity_privkey and sends it to non-initiator Niso.
34. Niso receives peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.
34n. Non-initiator Niso receives approvals_signed_by_boomlet_1 from non-initiator Boomlet and forwards it to WT.
35. WT receives peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Niso and approvals_signed_by_boomlet_i from each non-initiator Peer (async). It decrypts the message from Niso to get peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0 and verifies boomlet_0_identity_pubkey's signature. It then derives duress_placeholder by separating the padding from _peer_0_tx_commit_signed_by_boomlet_0_padded and sends it to ST. It also saves peer_0_tx_commit_signed_by_boomlet for later.
35n. WT receives approvals_signed_by_boomlet_1 from non-initiator Niso. WT verifies boomlet_1_identity_pubkey's signature on approvals_signed_by_boomlet_1 and checks the content to match peer_i_tx_approval_signed_by_peer_i[0 <= i <= 4] and wt_tx_approval. At the same time it receives approvals_received_by_peer_i [2 <= i <= 4] and repeats the same process.
36. SAR receives {duress_placeholder, boomlet_0_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_0_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a padding of False or a duress signal, if it was a duress signal and the pair of the received boomlet_0_identity_pubkey and AES iv of duress_placeholder was not previously received, It calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses this doxing_data to enter SEARCH AND RESCUE. Regardless of if the duress_placeholder is a false signal or not SAR signs duress_placeholder with the doxing_key and encrypts it with boomlet_0_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0.
37. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 from SAR and continue processing peer_0_tx_commit_signed_by_boomlet_0. It verifies boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, checks the magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. WT then signs peer_0_tx_commit_signed_by_boomlet_0 with wt_privkey and sends it to non-initiator peers. WT receives each peer i's peer_i_tx_commit_signed_by_boomlet_i in response and checks it's correctness in a similar manner. WT then sends the collection of peer_i_tx_commit_signed_by_boomlet_i to Niso alongside duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0.
38. Non-initiator Niso receives peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt from WT. Non-initiator Niso updates niso_1_event_block_height with the most_work_bitcoin_block_height, verifies wt_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, magic to match "commit", tx_id to be the expected value and event_block_height to be fresh according to most_work_bitcoin_block_height. Non-initiator Niso then forwards peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt alongside niso_1_event_block_height to Non-initiator Boomlet.
39. Non-initiator Boomlet receives {peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, niso_1_event_block_height} from non-initiator Niso. Non-initiator Boomlet verifies wt_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, magic to match "commit", tx_id to be the expected value and event_block_height to be fresh according to niso_1_event_block_height. Non-initiator Boomlet then generates peer_1_tx_commit composed of {"commit", tx_id, event_block_height}, signs it with boomlet_1_identity_privkey, pads it with duress_placeholder, signs it again and encrypts it with wt_pubkey. It then sends peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt to Niso.
40. Non-initiator Niso receives peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Boomlet and forwards it to WT.
41. WT receives peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Niso, decrypts it with wt_privkey, verifies boomlet_1_identity_pubkey's signature. It then derives duress_placeholder by separating the padding from peer_1_tx_commit_signed_by_boomlet_1_padded and sends it to SAR. It also saves peer_1_tx_commit_signed_by_boomlet for later.
42. SAR receives {duress_placeholder, boomlet_1_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_1_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a padding of False or a duress signal, if it was a duress signal and the pair of the received boomlet_1_identity_pubkey and AES iv of duress_placeholder was not previously received, It calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses this doxing_data to enter SEARCH AND RESCUE. Regardless of if the duress_placeholder is a false signal or not SAR signs duress_placeholder with the doxing_key and encrypts it with boomlet_1_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_1.
43. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_1 from SAR and continue processing peer_1_tx_commit_signed_by_boomlet_1. It verifies boomlet_1_identity_pubkey's signature on peer_1_tx_commit_signed_by_boomlet_1, checks the magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. WT then signs peer_1_tx_commit_signed_by_boomlet_1 with wt_privkey. WT then sends the collection of peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt [0 <= i <= 4] to Each Niso alongside it's respective duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_i.
44. Niso receives {Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [0 <= i <= 4], duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from WT. It then verifies wt_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt, each non-initiator peer i's boomlet_i_identity_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i, peer_i_tx_commit's magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. It then forwards Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [1 <= i <= 4], duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 and the latest block height it sees as niso_0_event_block_height to Boomlet.
45. Boomlet receives {Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [0 <= i <= 4], niso_0_event_block_height, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from Niso. It first decrypts duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0, verifies sar_pubkey's signature on duress_placeholder_signed_by_sar and checks to see if the content matches of the duress_placeholder that it had sent to WT. It then verifies wt_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt, each non-initiator peer i's boomlet_i_identity_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i, peer_i_tx_commit's magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh according to niso_0_event_block_height. After that Boomlet initializes counter with 0, reached_boomlets_collection with an empty set, ping_seq_num with 0, reached_mystery_flag with 0, sets last_seen_block to niso_0_event_block_height. Boomlet then constructs Ping composed of {"ping", tx_id, last_seen_block, ping_seq_num, reached_mystery_flag}, signs it with boomlet_0_identity_privkey, pads it with duress_placeholder, signs peer_0_ping_signed_by_boomlet_0_padded with boomlet_0_identity_privkey, encrypts the result with wt_pubkey and sends peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
46. Niso receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.
47. WT receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Niso (and peer_i_ping_signed_by_boomlet_i_padded_signed_by_boomlet_i_encrypted_by_boomlet_i_for_wt from Peers). If this is the first ping received, WT initializes reached_pings_collection with an empty set and goes into a loop that ends when reached_pings_collection[peer_i_id] has a valid value for every peer. WT decrypts peer_i_ping_signed_by_boomlet_i_padded_signed_by_boomlet_i and verifies boomlet_i_identity_pubkey's signature. Wt then separates duress_placeholder, which is the padding, and peer_i_ping and sends duress_placeholder and boomlet_0_identity_pubkey to peer 0's SAR.
48. SAR receives {duress_placeholder, boomlet_0_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_0_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a padding of False or a duress signal, if it was a duress signal and the pair of the received boomlet_0_identity_pubkey and AES iv of duress_placeholder was not previously received, It calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses this doxing_data to enter SEARCH AND RESCUE. Regardless of if the duress_placeholder is a false signal or not SAR signs duress_placeholder with the doxing_key and encrypts it with boomlet_0_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0.
49. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 from SAR and continue processing peer_0_ping_signed_by_boomlet_0(peer_i_ping_signed_by_boomlet_i). It verifies boomlet_i_identity_pubkey's signature on peer_i_ping_signed_by_boomlet_i, checks the magic to match "ping" and tx_id to be the one expected. If this is not the first ping It also checks that the ping_seq_num has been increased. Using ping's event_block_height, it checks that the ping is fresh and if it's the first ping received it checks that the reached_mystery_flag is not 1. If the mystery_flag is 1, WT assigns peer_i_ping_signed_by_boomlet_i to reached_pings_collection[peer_i_id]. WT constructs pong composed of {"pong", tx_id, most_work_bitcoin_block_height, Collection<peer_j_ping_signed_by_boomlet_j> [for each Peer i's pong include peer_j_ping_signed_by_boomlet_j of all other peers (i != j)] }, if it isn't the first pong composed WT waits for at least 1 block to pass. WT signs the pong and encrypts it for Boomlet to get pong_i_signed_by_wt_encrypted_by_wt_for_boomlet_i. It then sends pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0 alongside duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 to Niso and pong_i_signed_by_wt_encrypted_by_wt_for_boomlet_i [1<=i<=4] to other peers.
50. Niso receives {pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from WT and forwards them to Boomlet alongside the latest most_work_bitcoin_block_height as niso_0_event_block_height.
51. Boomlet receives {pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0, niso_0_event_block_height, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from Niso. It first decrypts duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0, verifies sar_pubkey's signature on duress_placeholder_signed_by_sar and checks to see if the content matches of the duress_placeholder that it had sent to WT. It then decrypts pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0 to get pong_0_signed_by_wt and verifies wt_pubkey's signature. Boomlet then checks the magic of pong_0 to match "pong", tx_id to match the expected value, pong to be fresh according to niso_0_event_block_height. It then takes out prev_ping_i_signed_by_boomlet_i from pong_0 for every other peer i, verifies boomlet_i_identity_pubkey's signature, checks that the magic is "ping", tx_id is the one expected, if it's not the first ping received the ping_seq_num has increased, if reached_boomlets_collection[peer_i_id] was previously assigned a value reached_mystery_flag is not 0. At this moment Boomlet generates a pseudo-random number which if modulo DURESS_CHECK_INTERVAL_IN_BLOCKS is 0 Boomlet enters into a duress_check to update duress_placeholder_plaintext. Otherwise it will continue with the old value.
52. Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
53. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assign a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them.
54. User receives duress_check_space from ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.
55. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for Boomlet and sends it to Iso.
56. Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
57. Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Niso. Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal.  If the duress_signal is composed of the same set of numbers as the duress_consent_set, duress_placeholder_plaintext will be assigned an empty padding otherwise it will be the doxing_key. duress_placeholder_plaintext will be encrypted to make up duress_placeholder.
58. Regardless of executing duress procedure, Boomlet encrypts duress_placeholder_plaintext with sar_pubkey to get duress_placeholder. It then checks to see if the conditions for incrementing counter are met namely if block_heights of last_seen_block, niso_0_event_block_height and prev_ping.last_seen_block are within a certain boundary. If for any of the peer_i_ids not appeared in reached_boomlets_collection, peer_i_prev_ping contain 1-valued reached_mystery_flag, Boomlet assigns peer_i_ping_signed_by_boomlet_i to reached_boomlets_collection[peer_i_id]. If Boomlet's own counter has reached it's mystery it updates reached_mystery_flag value to 1. It then updates the last_seen_block by taking the minimum of the current niso_0_event_block_height and the last_seen_block+10. Boomlet then regenerates ping with incremented ping_seq_num, signs it with peer_0_identity_pubkey, pads it with duress_placeholder, resigns it, encrypts it with wt_pubkey and sends the resulting peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
59. Niso receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.
60. WT receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and jumps back to the beginning of the PING_PONG_LOOP. if the loop breaks WT sends it's reached_pings_collection to all Peers.
61. Niso receives reached_pings_collection from WT. Niso checks the validity of each peer's peer_i_reached_ping_signed_by_boomlet_i. Niso then hydrates psbt and sends reached_pings_collection along with hydrated_psbt to Boomlet. 
62. Boomlet receives {reached_pings_collection, hydrated_psbt} from Niso. Boomlet first checks the validity of each peer's peer_i_reached_ping_signed_by_boomlet_i in reached_pings_collection. It then derives tx_id from hydrated_psbt and checks that it matches the one committed to and if so, updates the saved psbt with the hydrated_psbt.
63. Niso receives {magic: "withdrawal_ready_to_sign"} from Boomlet and proceeds to inform User to connect Boomlet to Iso.
64. User receives {magic: "withdrawal_ready_to_sign_received_connect_boomlet_to_iso"} from Niso and proceeds to connect Boomlet to Iso and input network, mnemonic and passphrase to Iso.
65. Iso receives {network, mnemonic, passphrase} from User and proceeds to inform Boomlet that they can start the musig protocol for tx_ins contained in the psbt.
66. Boomlet receives {magic: "withdrawal_initialized_start_signing"} from Iso and proceeds to share with it the information necessary for signing i.e. psbt, boomerang_descriptor, boomlet_0_boom_musig2_pubkey_share, alongside his own public nonce named pubnonce_boom.
67. Iso receives {psbt, boomerang_descriptor, boomlet_0_boom_musig2_pubkey_share, pubnonce_boom} from Boomlet. Iso then generates it's own public nonce and sends this pubnonce_normal alongside his partialsignature (partialsig_normal) to Boomlet.
68. Boomlet receives {pubnonce_normal, partialsig_normal} from Iso, proceeds to produce it's own partial signature and shares it with Iso. Boomlet saves signed psbt on it's own memory.
69. Iso receives partialsig_boom from Boomlet. Iso also keeps signed psbt but informs User that he can connect Boomlet to Niso.
70. User receives {magic: "withdrawal_psbt_signature_created_connect_boomlet_to_niso"} from Iso and proceeds to connect Boomlet to Niso.
71. Niso receives {magic: "withdrawal_peer_is_informed_that_boomlet_should_be_connected_to_niso"} from User and proceeds to ask Boomlet for the signed psbt.
72. Boomlet receives {magic: "withdrawal_signing_finished_export_signed_psbt"} from Niso and proceeds to respond to Niso with psbt_signed_0. It also clears it's memory of other withdrawal-specific information and regenerates mystery.
73. Niso receives psbt_signed_0 from Boomlet and forwards it to WT.
74. WT receives psbt_signed_0 from Niso and psbt_signed_i [1 <= i <= 4] from Peers. WT aggregates the signed_psbt's and relays the resulting signed_tx to the network.
