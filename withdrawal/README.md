# Boomerang withdrawal procedure

For the message sequence diagram, please refer to the [initiator svg](initiator_withdrawal_diagram_without_states.svg) and [non-initiator svg](non_initiator_withdrawal_diagram_without_states.svg) files.

1. Niso receives psbt from User. Niso checks that most_work_bitcoin_block_height has passed milestone_block_0 from boomerang_descriptor, meaning the bitcoin locked in boomerang is now spendable, derives tx_id from psbt and stores it. Niso also checks to see if psbt inputs are satisfiable. It sends the psbt alongside the latest block height to Boomlet for it to verify with User via ST.
2. Boomlet receives {psbt, niso_0_event_block_height} from Niso and checks to see if the niso_0_event_block_height has passed milestone_block_0. Boomlet then derives tx_id from psbt, committing to it fot the rest of the withdrawal ceremony, adds a nonce to it to ensure freshness of the response, encrypts it for st_0_identity_pubkey and sends it to Niso.
3. Niso receives tx_id_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
4. ST receives tx_id_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it, separates the nonce and sends the tx_id to User for him to verify it corresponds to the psbt he sent to Niso.
5. User receives tx_id from ST and checks to see if it matches that of the psbt he generated. User then informs ST of his acknowledgement of tx_id.
6. ST receives {magic: "withdrawal_initiator_peer_approved_that_txid_received_is_the_same_as_the_one_derived_from_withdrawal_psbt"} from User. ST then signs the tx_id_with_nonce it received with st_privkey and encrypts it using boomlet_0_identity_pubkey. It then sends this encrypted message to Niso.
7. Niso receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
8. Boomlet receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_0 from Niso, decrypts it, verifies st_0_identity_pubkey's signature and checks if the content is the same as the one sent i.e. User has acknowledged the tx_id and the message is fresh. To inform the WT and other Peers of the transaction, it then generates peer_0_tx_approval composed of {"approved", tx_id, event_block_height}, signs it using boomlet_0_identity_privkey and encrypts it for wt. It then encrypts psbt for every other boomlet_i using their respective identity_pubkey. Boomlet sends the resulting psbt_encrypted_collection alongside peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
9. Niso receives {peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, psbt_encrypted_collection: Collection<psbt_encrypted_by_boomlet_0_for_boomlet_i> [1 <= i <= 4]} from Boomlet and forwards them to WT.
10. WT receives {peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, psbt_encrypted_collection: Collection<psbt_encrypted_by_boomlet_0_for_boomlet_i> [1 <= i <= 4]} from Niso. WT decrypts peer_0_tx_approval_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt, verifies boomlet_0_identity_pubkey's signature and checks the string to match "approved". WT stores the tx_id from peer_0_tx_approval for the rest of the ceremony and checks that the event_block_height is fresh. Then it constructs it's own tx_approval composed of {"approved", tx_id,most_work_bitcoin_block_height, boomlet_0_identity_pubkey}, in which boomlet_0_identity_pubkey identifies the initiating peer for other non-initiator peers and signs it. To inform other peers' Boomlets of it's readiness for withdrawal for this transaction, WT sends to each non-initiator peer wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0 and psbt encrypted by that peer's boomlet_i_identity_pubkey.
11. Non-initiator Niso receives {wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0, psbt_encrypted_by_boomlet_0_for_boomlet_1} from WT. Non-initiator Niso verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt, finds out which peer is the initiator by looking at the initiator_id field of wt_tx_approval. It verifies that the boomlet_0_identity_pubkey derived from wt_tx_approval exists in the set of peer_ids_collection, It then verifies boomlet_0_identity_pubkey's signature on peer_0_tx_approval_signed_by_boomlet_0. Non-initiator Niso checks that the magic in peer_0_tx_approval and wt_tx_approval match "approved" , the tx_id in both approvals is the same, peer_0_tx_approval is fresh according to wt_tx_approval and wt_tx_approval is fresh according to most_work_bitcoin_block_height. It then checks that most_work_bitcoin_block_height has passed milestone_block_0 from boomerang_descriptor, meaning the bitcoin locked in boomerang is now spendable, and forwards the received message alongside niso_1_event_block_height to Non-initiator Boomlet.
12. Non-initiator Boomlet receives {wt_tx_approval_signed_by_wt, peer_0_tx_approval_signed_by_boomlet_0, psbt_encrypted_by_boomlet_0_for_boomlet_1, niso_1_event_block_height} from Non-initiator Niso. Non-initiator Boomlet verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt, finds out which peer is the initiator by looking at the initiator_id field of wt_tx_approval. It verifies that the boomlet_0_identity_pubkey derived from wt_tx_approval exists in the set of peer_ids_collection. It then verifies boomlet_0_identity_pubkey's signature on peer_0_tx_approval_signed_by_boomlet_0 and decrypts psbt_encrypted_by_boomlet_0_for_boomlet_1 using boomlet_1_identity_privkey and boomlet_0_identity_pubkey. Non-initiator Boomlet checks that the magic in peer_0_tx_approval and wt_tx_approval match "approved", the tx_ids in both approvals are the same as the one derived from psbt, peer_0_tx_approval is fresh according to wt_tx_approval, wt_tx_approval is fresh according to niso_1_event_block_height and niso_1_event_block_height has passed (is larger than) milestone_block_0. Non-initiator Boomlet then sends psbt to non-initiator Niso for it to show to non-initiator User.
13. Non-initiator Niso receives psbt from Non-initiator non-initiator Boomlet. Non-initiator Niso checks that psbt is satisfiable and tx_id derived from it matches that of peer_0_tx_approval. It then outputs psbt along with initiator's peer_0_id to non-initiator User for him to agree to.
14. Non-initiator User receives {psbt, initiator_peer_id} from non-initiator Niso. Non-initiator User then informs non-initiator Niso of it's agreement with the tx.
15. Non-initiator Niso receives {magic: "withdrawal_non_initiator_peer_approved_the_withdrawal_psbt"} from non-initiator User. Non-initiator Niso then informs non-initiator Boomlet to proceed and verify non-initiator User via ST.
16. Non-initiator Boomlet receives {magic: "withdrawal_peer_agreement_with_psbt_received"} from non-initiator Niso. Non-initiator Boomlet then derives tx_id from psbt, adds nonce to it to ensure freshness of the response and encrypts it using st_1_identity_pubkey. It then sends tx_id_with_nonce_encrypted_by_boomlet_1_for_st to non-initiator Niso.
17. Non-initiator Niso receives tx_id_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Boomlet and forwards it to non-initiator ST.
18. Non-initiator ST receives tx_id_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Niso. Non-initiator ST decrypts tx_id_with_nonce_encrypted_by_boomlet_1_for_st to get tx_id_with_nonce and outputs the content of it i.e. tx_id to non-initiator User for him to verify.
19. Non-initiator User receives tx_id from non-initiator ST. Non-initiator User checks to see tx_id matches the one derived from the psbt he previously received from non-initiator Niso and agreed to. It then informs non-initiator ST of his acknowledgement.
20. Non-initiator ST receives {magic: "withdrawal_non_initiator_peer_approved_that_txid_received_is_the_same_as_the_one_derived_from_wIthdrawal_psbt"} from non-initiator User. It signs the tx_id_with_nonce, encrypts it using boomlet_1_identity_pubkey and sends the result to non-initiator Niso.
21. Non-initiator Niso receives tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 from non-initiator ST. Non-initiator Niso forwards tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 along with the updated niso_1_event_block_height to non-initiator Boomlet.
22. Non-initiator Boomlet receives {tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1, niso_1_event_block_height} from non-initiator Niso. Non-initiator Boomlet decrypts tx_id_with_nonce_signed_by_st_encrypted_by_st_for_boomlet_1 using boomlet_1_identity_privkey to get tx_id_with_nonce_signed_by_st. It then verifies st_1_identity_pubkey's signature on tx_id_with_nonce_signed_by_st and checks if the tx_id_with_nonce received matches with the one sent. To inform Peers and WT of his approval, non-initiator Boomlet then generates peer_1_tx_approval composed of {"approved", tx_id, niso_1_event_block_height}, signs it using boomlet_1_identity_privkey, encrypts it using wt_pubkey and sends peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt to non-initiator Niso.
23. Non-initiator Niso receives peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Boomlet and forwards it to WT.
24. WT receives peer_1_tx_approval_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Niso, decrypts it using wt_privkey, verifies boomlet_1_identity_pubkey's signature on peer_1_tx_approval_signed_by_boomlet_1, checks that the magic matches "approved", tx_id match the expected value and message to be fresh according to the most_work_bitcoin_block_height and event_block_height of wt_tx_approval. It also receives peer_i_tx_approval_signed_by_boomlet_i_encrypted_by_boomlet_i_for_wt from non-initiator Peers and repeats the same validation process. To inform every peer of other peers' agreements, WT then sends a collection of all other peers' approvals except the initiator's which it had previously sent to each non-initiator peer and in a separate message sends a collection of all peers' approvals along with wt_tx_approval to the initiator peer.
25. Niso receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [0 <= i <= 4], wt_tx_approval_signed_by_wt} from WT. Niso verifies each boomlet_i_identity_pubkey's signature on each peer_i_tx_approval_signed_by_boomlet_i and verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt. It checks the magic string for every approval to match "approved", the tx_id to match what was sent and the event_block_heights to be in the appropriate range. It forwards Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4] along with the latest block to Boomlet.
26. Non-initiator Niso receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4]} from WT. Non-initiator Niso updates niso_1_event_block_height with the latest most_work_bitcoin_block_height. For every non_initiator peer in peer_ids_collection, It verifies boomlet_i_identity_pubkey's signature on peer_i_tx_approval_signed_by_boomlet_i, checks that the magic matches "approved", tx_id to be the expected value, peer_i_tx_approval to be fresh according to niso_1_event_block_height and wt_tx_approval and checks that wt_tx_approval is still fresh. It forwards this Collection<peer_i_tx_approval_signed_by_boomlet_i> alongside niso_1_event_block_height to non-initiator Boomlet.
27. Boomlet receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4], wt_tx_approval_signed_by_wt, niso_0_event_block_height} from Niso. Boomlet verifies each boomlet_i_identity_pubkey's signature on each peer_i_tx_approval_signed_by_boomlet_i, verifies wt_pubkey's signature on wt_tx_approval_signed_by_wt and updates niso_0_event_block_height with the new value. It checks the magic string for every approval to match "approved", the tx_id to match what was sent and the event_block_heights to be in the appropriate range. Knowing all peers and wt have approved the transaction, to make sure User who is the only other entity aware of duress_consent_set consents to the transaction and if otherwise is under coercion will send the signal making rescue possible. Boomlet then generates duress_check_space which is an array of 5 integers between 1 and 195, adds a nonce to it to ensure response's freshness and encrypts it using st_0_identity_pubkey. Then Boomlet sends duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st to Niso.
    
    27n. Non-initiator Boomlet receives {Collection<peer_i_tx_approval_signed_by_boomlet_i> [1 <= i <= 4], niso_1_event_block_height} from non-initiator Niso. After renewing niso_1_event_block_height, for every peer in peer_ids_collection except the initiator, non-initiator Boomlet verifies boomlet_i_identity_pubkey's signature on peer_i_tx_approval_signed_by_boomlet_i, checks that the magic matches "approved", tx_id to be the expected value, peer_i_tx_approval to be fresh according to niso_1_event_block_height and wt_tx_approval and checks that wt_tx_approval is still fresh. Knowing all peers and wt have approved the transaction, to make sure User is not under duress, non-initiator Boomlet then generates duress_check_space which is an array of 5 integers between 1 and 195, adds a nonce to it to ensure response's freshness and encrypts it using st_1_identity_pubkey. Then non-initiator Boomlet sends duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st to non-initiator Niso.
28. Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.

    28n. Non-initiator Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Boomlet and forwards it to non-initiator ST.
29. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assigns a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them to show he is not in duress.

    29n. Non-initiator ST receives duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st from non-initiator Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_1_for_st, assigns a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to non-initiator User for him to select 5 of them to show he is not in duress.

30. User receives duress_check_space from ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.

    30n. Non-initiator User receives duress_check_space from non-initiator ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to non-initiator ST.
31. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce to show message's freshness to Boomlet, encrypts it for Boomlet and sends it to Niso.

    31n. Non-initiator ST receives duress_signal_index from non-initiator User. Non-initiator ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce to show message's freshness to non-initiator Boomlet, encrypts it for non-initiator Boomlet and sends it to Niso.
32. Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.

    32n. Non-initiator Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_1 from non-initiator ST and forwards it to non-initiator Boomlet.
33. Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Niso. Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal. If the duress_signal is composed of the same set of numbers as the duress_consent_set, duress_placeholder_plaintext will be assigned an empty padding otherwise it will be the doxing_key so that SAR will be able to decrypt static_doxing_data and dynamic_doxing_data and come to rescue. duress_placeholder_plaintext will be encrypted with sar_pubkey to make up duress_placeholder. Boomlet then constructs peer_0_tx_commit composed of {"commit", tx_id,  niso_0_event_block_height}, signs it, pads it with duress_placeholder, signs the padded value, encrypts it using wt_pubkey and sends the result to Niso.

    33n. Non-initiator Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_1 from non-initiator Niso. Non-initiator Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal. If the duress_signal is composed of the same set of numbers as the duress_consent_set, duress_placeholder_plaintext will be assigned an empty padding otherwise it will be the doxing_key so that SAR will be able to decrypt static_doxing_data and dynamic_doxing_data and come to rescue. duress_placeholder_plaintext will be encrypted with non-initiator peer's SAR's sar_pubkey to make up duress_placeholder. Non-initiator Boomlet then generates approvals composed of peer_i_tx_approval_signed_by_peer_i [0 <= i <= 4] and wt_tx_approval, signs it using boomlet_1_identity_privkey and sends it to non-initiator Niso.
34. Niso receives peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.

    34n. Non-initiator Niso receives approvals_signed_by_boomlet_1 from non-initiator Boomlet and forwards it to WT.
35. WT receives peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Niso and approvals_signed_by_boomlet_i from each non-initiator peer (async). It decrypts the message from Niso to get peer_0_tx_commit_signed_by_boomlet_0_padded_signed_by_boomlet_0 and verifies boomlet_0_identity_pubkey's signature. It then derives duress_placeholder by separating the padding from peer_0_tx_commit_signed_by_boomlet_0_padded and sends it to SAR. It also saves peer_0_tx_commit_signed_by_boomlet to process after receiving SAR's answer.

    35n. WT receives approvals_signed_by_boomlet_1 from non-initiator Niso. WT verifies boomlet_1_identity_pubkey's signature on approvals_signed_by_boomlet_1 and checks the content to match peer_i_tx_approval_signed_by_peer_i[0 <= i <= 4] and wt_tx_approval. At the same time it receives approvals_received_by_peer_i [2 <= i <= 4] and repeats the same process.
36. SAR receives {duress_placeholder, boomlet_0_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_0_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a zero-padding or a duress signal, if it was a duress signal and the pair of the received boomlet_0_identity_pubkey and AES iv of duress_placeholder was not previously saved, it calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses these doxing data to enter SEARCH AND RESCUE. Regardless of whether the duress_placeholder is a duress signal or not, SAR signs duress_placeholder with sar_privkey and encrypts it using boomlet_0_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0.
37. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 from SAR and continue processing peer_0_tx_commit_signed_by_boomlet_0. It verifies boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, checks the magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. WT then signs peer_0_tx_commit_signed_by_boomlet_0 with wt_privkey to acknowledge he has received the commit and sends it to non-initiator peers.
38. Non-initiator Niso receives peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt from WT. Non-initiator Niso updates niso_1_event_block_height with the most_work_bitcoin_block_height, verifies wt_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, magic to match "commit", tx_id to be the expected value and event_block_height to be fresh according to most_work_bitcoin_block_height. Non-initiator Niso then forwards peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt alongside niso_1_event_block_height to non-initiator Boomlet.
39. Non-initiator Boomlet receives {peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, niso_1_event_block_height} from non-initiator Niso. Non-initiator Boomlet verifies wt_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0_signed_by_wt, boomlet_0_identity_pubkey's signature on peer_0_tx_commit_signed_by_boomlet_0, magic to match "commit", tx_id to be the expected value and event_block_height to be fresh according to niso_1_event_block_height. Non-initiator Boomlet then generates it's own peer_1_tx_commit composed of {"commit", tx_id, event_block_height}, signs it using boomlet_1_identity_privkey, pads it with duress_placeholder, signs it again and encrypts it using wt_pubkey. It then sends peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt to Niso.
40. Non-initiator Niso receives peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Boomlet and forwards it to WT.
41. WT receives peer_1_tx_commit_signed_by_boomlet_1_padded_signed_by_boomlet_1_encrypted_by_boomlet_1_for_wt from non-initiator Niso, decrypts it with wt_privkey, verifies boomlet_1_identity_pubkey's signature. It then derives duress_placeholder by separating the padding from peer_1_tx_commit_signed_by_boomlet_1_padded and sends it to SAR. It also saves peer_1_tx_commit_signed_by_boomlet to process after receiving SAR's answer.
42. SAR receives {duress_placeholder, boomlet_1_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_1_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a zero-padding or a duress signal, if it was a duress signal and the pair of the received boomlet_1_identity_pubkey and AES iv of duress_placeholder was not previously saved, It calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses these doxing data to enter SEARCH AND RESCUE. Regardless of whether the duress_placeholder is a duress signal or not, SAR signs duress_placeholder using sar_privkey and encrypts it using boomlet_1_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_1.
43. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_1 from SAR and continue processing peer_1_tx_commit_signed_by_boomlet_1. It verifies boomlet_1_identity_pubkey's signature on peer_1_tx_commit_signed_by_boomlet_1, checks the magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. WT then signs peer_1_tx_commit_signed_by_boomlet_1 with wt_privkey to acknowledge he has received the commit. WT then sends the collection of peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt [0 <= i <= 4] to each Niso alongside it's respective duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_i.
44. Niso receives {Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [0 <= i <= 4], duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from WT. It then verifies wt_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt, each non-initiator peer i's boomlet_i_identity_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i, peer_i_tx_commit's magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh. It then forwards Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [1 <= i <= 4], duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 and the latest block height it sees as niso_0_event_block_height to Boomlet.
45. Boomlet receives {Collection<peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt> [0 <= i <= 4], niso_0_event_block_height, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from Niso. It first decrypts duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0, verifies sar_pubkey's signature on duress_placeholder_signed_by_sar and checks to see if the content matches of the duress_placeholder that it had sent to WT. It then verifies wt_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i_signed_by_wt, each non-initiator peer i's boomlet_i_identity_pubkey's signature on peer_i_tx_commit_signed_by_boomlet_i, peer_i_tx_commit's magic to match "commit", tx_id to be the one expected and for the event_block_height to be fresh according to niso_0_event_block_height. After that Boomlet proceeds to start the digging game. To do this, it initializes counter, which is going to count the number of successful digging rounds, with 0, reached_boomlets_collection, which will hold the Boomlets that have reached their mystery threshold and are ready to sign, with an empty set, ping_seq_num, which is a sequence number unique for each of the Boomlet's pings, with 0, reached_mystery_flag, which shows whether or not the mystery threshold has been reached, with 0, sets last_seen_block, which will hold the block received when creating the previous ping, to niso_0_event_block_height. Boomlet then constructs Ping composed of {"ping", tx_id, last_seen_block, ping_seq_num, reached_mystery_flag}, signs it using boomlet_0_identity_privkey, pads it with duress_placeholder that's meant for SAR, signs peer_0_ping_signed_by_boomlet_0_padded again with boomlet_0_identity_privkey, encrypts the result with wt_pubkey and sends peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
46. Niso receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.
47. WT receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Niso (and peer_i_ping_signed_by_boomlet_i_padded_signed_by_boomlet_i_encrypted_by_boomlet_i_for_wt from Peers). If this is the first ping received, WT initializes reached_pings_collection with an empty set and goes into a loop that ends when reached_pings_collection[peer_i_id] has a valid value for every peer meaning every Boomlet has announced it has reached the mystery threshold needed to collaborate in signing the transaction. WT decrypts peer_i_ping_signed_by_boomlet_i_padded_signed_by_boomlet_i and verifies boomlet_i_identity_pubkey's signature. Wt then separates duress_placeholder, which is the padding, and peer_i_ping and sends duress_placeholder and boomlet_0_identity_pubkey to peer 0's SAR.
48. SAR receives {duress_placeholder, boomlet_0_identity_pubkey} from WT. It decrypts duress_placeholder using boomlet_0_identity_pubkey and sar_privkey to get duress_placeholder_plaintext. It checks to see if it's a zero-padding or a duress signal, if it was a duress signal and the pair of the received boomlet_0_identity_pubkey and AES iv of duress_placeholder was not previously saved, It calculates doxing_data_identifier by hashing duress_placeholder, uses it to find which doxing_data is associated with this user and then uses duress_placeholder which is equal to doxing_key to decrypt the associated static_doxing_data_encrypted_by_doxing_key and dynamic_doxing_data_encrypted_by_doxing_key. It then uses these doxing data to enter SEARCH AND RESCUE. Regardless of whether the duress_placeholder is a duress signal or not, SAR signs duress_placeholder using sar_privkey and encrypts it using boomlet_0_identity_pubkey. It then responds to WT with the duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0.
49. WT receives duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 from SAR and continue processing peer_0_ping_signed_by_boomlet_0(peer_i_ping_signed_by_boomlet_i). It verifies boomlet_i_identity_pubkey's signature on peer_i_ping_signed_by_boomlet_i, checks the magic to match "ping" and tx_id to be the one expected. If this is not the first ping It also checks that the ping_seq_num has been increased ensuring ping is not seen before. Using ping's event_block_height, it checks that the ping is fresh and if it's the first ping received it checks that the reached_mystery_flag is not 1 as it's expected of Boomlet to have non-negative non-zero threshold for withdrawal. If the mystery_flag is 1, WT assigns peer_i_ping_signed_by_boomlet_i to reached_pings_collection[peer_i_id]. WT constructs pong composed of {"pong", tx_id, most_work_bitcoin_block_height, Collection<peer_j_ping_signed_by_boomlet_j> [for each Peer i's pong include peer_j_ping_signed_by_boomlet_j of all other peers (i != j)] }, if it isn't the first pong composed WT waits for at least 1 block to pass so that the pong increments every Boomlet's counter. WT signs pong and encrypts it for Boomlet to get pong_i_signed_by_wt_encrypted_by_wt_for_boomlet_i. It then sends pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0 alongside duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0 to Niso and pong_i_signed_by_wt_encrypted_by_wt_for_boomlet_i [1 <= i <= 4] to other peers.
50. Niso receives {pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from WT and forwards them to Boomlet alongside the latest most_work_bitcoin_block_height as niso_0_event_block_height.
51. Boomlet receives {pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0, niso_0_event_block_height, duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0} from Niso. It first decrypts duress_placeholder_signed_by_sar_encrypted_by_sar_for_boomlet_0, verifies sar_pubkey's signature on duress_placeholder_signed_by_sar and checks to see if the content matches of the duress_placeholder that it had sent to WT hence knowing that the duress_placeholder has reached SAR. It then decrypts pong_0_signed_by_wt_encrypted_by_wt_for_boomlet_0 to get pong_0_signed_by_wt and verifies wt_pubkey's signature. Boomlet then checks the magic of pong_0 to match "pong", tx_id to match the expected value, pong to be fresh according to niso_0_event_block_height. It then takes out prev_ping_i_signed_by_boomlet_i from pong_0 for every other peer i, verifies boomlet_i_identity_pubkey's signature, checks that the magic is "ping", tx_id is the one expected, if it's not the first ping received the ping_seq_num has increased, if reached_boomlets_collection[peer_i_id] was previously assigned a value reached_mystery_flag is not 0 as once a Boomlet reaches mystery threshold it is not supposed to back off. At this moment Boomlet generates a pseudo-random number which if modulo DURESS_CHECK_INTERVAL_IN_BLOCKS is 0 Boomlet enters into a duress_check to update duress_placeholder_plaintext with, ensuring User who is the only other entity aware of duress_consent_set still agrees to the transaction and if otherwise is under coercion will send the signal making rescue possible. Otherwise it will continue with the old value for duress_placeholder_plaintext.
52. Niso receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Boomlet and forwards it to ST.
53. ST receives duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st from Niso, decrypts it to get duress_check_space_with_nonce_encrypted_by_boomlet_0_for_st, assigns a country to each of the numbers in the duress_check_space corresponding to its alphabetical rank and shows this array to User for him to select 5 of them.
54. User receives duress_check_space from ST. If he is not being coerced he will select 1 country in each column to replicate the duress_consent_set and inputs it to ST.
55. ST receives duress_signal_index from User. ST then creates duress_signal_index_with_nonce using the nonce from previously received duress_check_space_with_nonce, encrypts it for Boomlet and sends it to Niso.
56. Niso receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from ST and forwards it to Boomlet.
57. Boomlet receives duress_signal_index_with_nonce_encrypted_by_st_for_boomlet_0 from Niso. Boomlet will search for the indices in duress_check_space assigning the resulting value to duress_signal. If the duress_signal is composed of the same set of numbers as the duress_consent_set, which means User is not under duress, duress_placeholder_plaintext will be assigned an empty padding otherwise, which means User is under duress, it will be the doxing_key making the decryption of doxing data possible.

    Regardless of executing duress procedure, Boomlet encrypts duress_placeholder_plaintext with sar_pubkey to get duress_placeholder. This is to ensure no two pings have the same ciphertext as duress_placeholder, giving no information about the content to WT. It then checks to see if the conditions for incrementing counter are met namely if block_heights of last_seen_block, niso_0_event_block_height and prev_ping.last_seen_block are within a certain boundary. If for any of the peer_i_ids not appeared in reached_boomlets_collection, peer_i_prev_ping contain 1-valued reached_mystery_flag, Boomlet assigns peer_i_ping_signed_by_boomlet_i to reached_boomlets_collection[peer_i_id]. If Boomlet's own counter has reached it's mystery, it updates reached_mystery_flag value to 1. It then updates the last_seen_block by taking the minimum of the current niso_0_event_block_height and the last_seen_block + JUMP_IN_BLOCKS_IF_LAST_SEEN_BLOCK_LAGS_BEHIND_NISO_EVENT_BLOCK_HEIGHT_IN_BOOMLET. Boomlet then regenerates ping with incremented ping_seq_num, signs it using peer_0_identity_privkey, pads it with duress_placeholder, signs it again, encrypts it using wt_pubkey and sends the resulting peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt to Niso.
58. Niso receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Boomlet and forwards it to WT.
59. WT receives peer_0_ping_signed_by_boomlet_0_padded_signed_by_boomlet_0_encrypted_by_boomlet_0_for_wt from Niso and jumps back to the beginning of the PING_PONG_LOOP. If the loop breaks it meaning every Boomlet has reached it's own mystery threshold and informed WT, WT sends it's reached_pings_collection to all Peers.
60. Niso receives reached_pings_collection from WT. Niso verifies each peer's peer_i_reached_ping_signed_by_boomlet_i. Niso then hydrates psbt so that Boomlet can collaborate with Iso to sign it's relevant inputs and sends reached_pings_collection along with hydrated_psbt to Boomlet. 
61. Boomlet receives {reached_pings_collection, hydrated_psbt} from Niso. Boomlet first checks the validity of each peer's peer_i_reached_ping_signed_by_boomlet_i in reached_pings_collection. It then derives tx_id from hydrated_psbt and checks that it matches the one committed to at the start of the ceremony and if so, updates the saved psbt with the hydrated_psbt.
62. Niso receives {magic: "withdrawal_ready_to_sign"} from Boomlet and proceeds to inform User to connect Boomlet to Iso.
63. User receives {magic: "withdrawal_ready_to_sign_received_connect_boomlet_to_iso"} from Niso and proceeds to connect Boomlet to Iso and input network, mnemonic and passphrase to Iso which are needed for Iso to sign the transaction with.
64. Iso receives {network, mnemonic, passphrase} from User and proceeds to inform Boomlet that they can start collaboratively signing tx_ins contained in the psbt.
65. Boomlet receives {magic: "withdrawal_initialized_start_signing"} from Iso and proceeds to share with it the information necessary for signing i.e. psbt, boomerang_descriptor, boomlet_0_boom_musig2_pubkey_share, alongside his own public nonce named pubnonce_boom.
66. Iso receives {psbt, boomerang_descriptor, boomlet_0_boom_musig2_pubkey_share, pubnonce_boom} from Boomlet. Iso then generates it's own public nonce and sends this pubnonce_normal alongside his partialsignature (partialsig_normal) to Boomlet.
67. Boomlet receives {pubnonce_normal, partialsig_normal} from Iso, proceeds to produce it's own partial signature and shares it with Iso. Boomlet saves signed psbt on it's own memory.
68. Iso receives partialsig_boom from Boomlet. Iso also keeps signed psbt but informs User that he can connect Boomlet to Niso.
69. User receives {magic: "withdrawal_psbt_signature_created_connect_boomlet_to_niso"} from Iso and proceeds to connect Boomlet to Niso.
70. Niso receives {magic: "withdrawal_peer_is_informed_that_boomlet_should_be_connected_to_niso"} from User and proceeds to ask Boomlet for the signed psbt.
71. Boomlet receives {magic: "withdrawal_signing_finished_export_signed_psbt"} from Niso and proceeds to respond to Niso with psbt_signed_0. It also clears it's memory of other withdrawal-specific information and regenerates mystery.
72. Niso receives psbt_signed_0 from Boomlet and forwards it to WT.
73. WT receives psbt_signed_0 from Niso and psbt_signed_i [1 <= i <= 4] from Peers. WT aggregates the signed_psbt's and relays the resulting signed_tx to the network.
